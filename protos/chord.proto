
syntax = "proto3";
package chord;

import "google/protobuf/empty.proto";

service Node {

  // Application Level RPC Calls
  rpc summary(Trash) returns (NodeAddress) {}

  // Once a client knows the node to connect to, it can fetch the data
  rpc fetch (UserRequest) returns (User) {}
  // Once a client knows the node to connect to, we can insert the user at that node.
  rpc insert (UserEdit) returns (google.protobuf.Empty) {}
  rpc insertUserRemoteHelper (UserEdit) returns (google.protobuf.Empty) {}
  rpc lookup (UserRequest) returns (User) {}
  rpc lookupUserRemoteHelper (UserRequest) returns (User) {}
  rpc remove(UserRequest) returns (google.protobuf.Empty){}
  rpc removeUserRemoteHelper(UserRequest) returns (google.protobuf.Empty){}
  rpc migrateUsersToPredecessorRemoteHelper(google.protobuf.Empty) returns (google.protobuf.Empty){}
  
  // Chord Library Level RPC Calls
  rpc getNodeIdRemoteHelper (NodeAddress) returns (NodeAddress) {}
  rpc findSuccessorRemoteHelper (RemoteId) returns (NodeAddress) {}
  rpc getSuccessorRemoteHelper (NodeAddress) returns (NodeAddress) {}
  rpc setSuccessor (NodeAddress) returns (google.protobuf.Empty) {}
  rpc getPredecessor (NodeAddress) returns (NodeAddress) {}
  rpc setPredecessor (NodeAddress) returns (google.protobuf.Empty) {}
  rpc getFingerTableEntries (NodeAddress) returns (stream FingerTableEntry) {}
  rpc closestPrecedingFingerRemoteHelper (RemoteId) returns (NodeAddress) {}
  rpc notify (NodeAddress) returns (google.protobuf.Empty) {}
  rpc updateFingerTable (FingerTableEntry) returns (NodeAddress) {}
}

message NodeId {
  uint32 id = 1;
}

message NodeAddress {
  uint32 id = 1;
  string host = 2;
  uint32 port = 3;
}

message RemoteId {
  uint32 id = 1;
  NodeAddress node = 2;
}

message FingerTableEntry {
  NodeAddress node = 1;
  uint32 index = 2;
 }

message Trash{
  uint32 id = 1;
}

// The request message containing the user's name.
message UserRequest {
  int32 id = 1;
}

// A User seems to have a local Id and profile associated with the StackOverflow group. These Ids are tied together via AccountIds
// For the chord project, I think we can just hash off the Id key, since these are unique.
message User {
  int32 id = 1;
  int32 reputation = 2;
  string creationDate = 3;
  string displayName = 4;
  string lastAccessDate = 5;
  string websiteUrl = 6;
  string location = 7;
  string aboutMe = 8;
  int32 views = 9;
  int32 upVotes = 10;
  int32 downVotes = 11;
  string profileImageUrl = 12;
  int32 accountId = 13;
}

message UserEdit {
  User user = 1;
  bool edit = 2; 
}





